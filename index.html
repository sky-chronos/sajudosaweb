<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Sky Chronos â€” NASA ë°©ì‹ íƒœì–‘í™©ê²½ ê¸°ë°˜ ì ˆê¸°Â·ì›”ì§€Â·ì‹œì£¼</title>
<style>
  :root{--bg:#0b1020;--card:#101833;--text:#e9ecf6;--muted:#9fb0d0;--accent:#6ea8ff}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;padding:16px;padding-bottom:120px}
  h1{margin:0 0 12px 0;font-size:22px;letter-spacing:-.2px}
  .card{background:var(--card);border-radius:16px;padding:14px;margin-bottom:12px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:12px;color:var(--muted);display:block;margin:10px 0 6px}
  input,select{background:#0e1530;color:var(--text);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:12px;font-size:14px}
  input[type="date"]{min-width:160px}
  input[type="time"]{min-width:140px}
  button{width:100%;padding:14px;border-radius:12px;border:none;font-weight:900;background:var(--accent);color:#000;font-size:15px}
  button:active{transform:translateY(1px)}
  .grid{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:860px){.grid{grid-template-columns:1fr 1fr}}
  .kv{display:flex;justify-content:space-between;gap:14px;padding:10px 12px;background:#0e1530;border:1px solid rgba(255,255,255,.07);border-radius:14px}
  .k{color:var(--muted);font-size:12px}
  .v{font-weight:800}
  pre{white-space:pre-wrap;word-break:break-word;background:#0e1530;border:1px solid rgba(255,255,255,.07);border-radius:14px;padding:12px;margin:10px 0 0 0}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:#0e1530;border:1px solid rgba(255,255,255,.09);color:var(--muted);font-size:12px;margin-top:8px}
  .small{font-size:12px;color:var(--muted);line-height:1.45}
</style>
</head>

<body>
<h1>NASA ë°©ì‹ íƒœì–‘í™©ê²½ ê¸°ë°˜ ì ˆê¸°Â·ì›”ì§€Â·ì‹œì£¼ â€” Sky Chronos (v4)</h1>

<div class="card">
  <div class="row">
    <div>
      <label>ë‚ ì§œ</label>
      <input id="date" type="date" />
    </div>
    <div>
      <label>ì‹œê°(í•œêµ­ì‹œê°„)</label>
      <input id="time" type="time" value="21:39" />
    </div>
    <div>
      <label>ê³„ì‚° ì˜µì…˜</label>
      <select id="mode">
        <option value="apparent">ê²‰ë³´ê¸° íƒœì–‘ í™©ê²½(ì¶”ì²œ)</option>
        <option value="mean">í‰ê·  íƒœì–‘ í™©ê²½(ë””ë²„ê·¸ìš©)</option>
      </select>
    </div>
  </div>

  <div class="small" style="margin-top:10px">
    - GitHub Pages/ëª¨ë°”ì¼ ì•ˆì • ë²„ì „ (SPICE/WASM ë¯¸ì‚¬ìš©)<br/>
    - ì ˆê¸° íŒì •ì€ íƒœì–‘ í™©ê²½ì´ 15Â° ë‹¨ìœ„ë¥¼ í†µê³¼í•˜ëŠ” ìˆœê°„ ê¸°ì¤€<br/>
    - ê²‰ë³´ê¸°/í‰ê·  ëª¨ë“œ ì œê³µ (ê²‰ë³´ê¸° = nutation + aberration ê·¼ì‚¬ í¬í•¨)
  </div>

  <div style="margin-top:12px">
    <button onclick="calc()">NASA ê¸°ì¤€ ê³„ì‚°</button>
  </div>
</div>

<div class="card">
  <h3 style="margin:0 0 10px 0">ê²°ê³¼</h3>
  <div class="grid">
    <div class="kv"><div class="k">íƒœì–‘ í™©ê²½ (Î»)</div><div class="v" id="lon">â€”</div></div>
    <div class="kv"><div class="k">ì ˆê¸°</div><div class="v" id="term">â€”</div></div>
    <div class="kv"><div class="k">ì ˆê¸° ê²½ê³„</div><div class="v" id="boundary">â€”</div></div>
    <div class="kv"><div class="k">ì›”ì§€(ì ˆê¸°ì›”)</div><div class="v" id="monthBranch">â€”</div></div>
    <div class="kv"><div class="k">ì‹œì£¼(ì‹œì§€)</div><div class="v" id="hourBranch">â€”</div></div>
  </div>
  <div class="pill" id="quality">â€”</div>
  <div class="small" id="note" style="margin-top:10px">â€”</div>
</div>

<div class="card">
<h3 style="margin:0 0 8px 0">GPTìš© ì¶œë ¥</h3>
<div class="row">
  <button onclick="copyGPT()">ğŸ“‹ ê²°ê³¼ ë³µì‚¬</button>
  <button onclick="openGPT()">ğŸ¤– GPTì—ì„œ í•´ì„</button>
</div>
<pre id="raw">â€”</pre>

</div>

<script>
/* ========= Basics ========= */
const solarTerms = [
  {deg:0, name:"ì¶˜ë¶„"},{deg:15,name:"ì²­ëª…"},{deg:30,name:"ê³¡ìš°"},{deg:45,name:"ì…í•˜"},
  {deg:60,name:"ì†Œë§Œ"},{deg:75,name:"ë§ì¢…"},{deg:90,name:"í•˜ì§€"},{deg:105,name:"ì†Œì„œ"},
  {deg:120,name:"ëŒ€ì„œ"},{deg:135,name:"ì…ì¶”"},{deg:150,name:"ì²˜ì„œ"},{deg:165,name:"ë°±ë¡œ"},
  {deg:180,name:"ì¶”ë¶„"},{deg:195,name:"í•œë¡œ"},{deg:210,name:"ìƒê°•"},{deg:225,name:"ì…ë™"},
  {deg:240,name:"ì†Œì„¤"},{deg:255,name:"ëŒ€ì„¤"},{deg:270,name:"ë™ì§€"},{deg:285,name:"ì†Œí•œ"},
  {deg:300,name:"ëŒ€í•œ"},{deg:315,name:"ì…ì¶˜"},{deg:330,name:"ìš°ìˆ˜"},{deg:345,name:"ê²½ì¹©"}
];
const branches = ["ì","ì¶•","ì¸","ë¬˜","ì§„","ì‚¬","ì˜¤","ë¯¸","ì‹ ","ìœ ","ìˆ ","í•´"];

function pad(n){return String(n).padStart(2,"0");}
function norm360(x){x%=360; if(x<0)x+=360; return x;}
function deg2rad(d){return d*Math.PI/180;}
function rad2deg(r){return r*180/Math.PI;}
function clamp(x,a,b){return Math.max(a,Math.min(b,x));}

function kstToUTCISOString(dateStr,timeStr){
  // KST = UTC+9
  const [Y,M,D]=dateStr.split("-").map(Number);
  const [h,m]=timeStr.split(":").map(Number);
  const utc = new Date(Date.UTC(Y,M-1,D,h-9,m,0));
  return utc.toISOString().replace(".000Z","");
}
function parseKST(dateStr,timeStr){
  // local-like object but deterministic: treat as KST wall time
  const [Y,M,D]=dateStr.split("-").map(Number);
  const [h,m]=timeStr.split(":").map(Number);
  return {Y,M,D,h,m};
}
function openGPT(){
  const text = document.getElementById("raw").textContent;
  if(!text || text.trim() === "â€”"){
    alert("ë¨¼ì € NASA ê¸°ì¤€ ê³„ì‚°ì„ ì‹¤í–‰í•˜ì„¸ìš”.");
    return;
  }

  // ë¡œê·¸ë¥¼ ìë™ìœ¼ë¡œ ë³µì‚¬
  navigator.clipboard.writeText(text);

  // Sky Chronos GPT (ë‹¹ì‹ ì˜ GPT ë§í¬ë¡œ êµì²´)
  const url = "https://chat.openai.com/g/g-xxxxxxxx-sky-chronos";

  window.open(url, "_blank");

  alert("ê³„ì‚° ê²°ê³¼ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.\nGPT ì°½ì´ ì—´ë¦¬ë©´ ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”.");
}


  
/* ========= Astronomy (NOAA-style, debug-friendly) =========
   ëª©í‘œ: íƒœì–‘ ê²‰ë³´ê¸° í™©ê²½ Î»_app (deg), í‰ê·  í™©ê²½ Î»_mean (deg)
   - Julian Day from UTC
   - Mean longitude L0
   - Mean anomaly M
   - Equation of center C
   - True longitude = L0 + C
   - Apparent longitude = true - 0.00569 - 0.00478*sin(Î©)
   - Nutation proxy via Î© (ascending node of Moon)
   ì°¸ê³ : ì ˆê¸°/ì‚¬ì£¼ ê²½ê³„ì— ì¶©ë¶„í•œ ì •ë°€ë„(ì´ˆ ë‹¨ìœ„ ê·¼ì‚¬ ê°€ëŠ¥), êµ¬í˜„ ë‹¨ìˆœ/ë””ë²„ê¹… ì‰¬ì›€
*/

function julianDayFromUTC(isoUtc){
  // isoUtc: "YYYY-MM-DDTHH:MM:SS"
  const d = new Date(isoUtc + "Z");
  const Y = d.getUTCFullYear();
  const M = d.getUTCMonth() + 1;
  const D = d.getUTCDate();
  const hh = d.getUTCHours();
  const mm = d.getUTCMinutes();
  const ss = d.getUTCSeconds();

  let a = Math.floor((14 - M)/12);
  let y = Y + 4800 - a;
  let m = M + 12*a - 3;
  let JDN = D + Math.floor((153*m + 2)/5) + 365*y + Math.floor(y/4) - Math.floor(y/100) + Math.floor(y/400) - 32045;
  const dayFrac = (hh - 12)/24 + mm/1440 + ss/86400;
  return JDN + dayFrac;
}

function solarLongitude(isoUtc, mode){
  const JD = julianDayFromUTC(isoUtc);
  const T = (JD - 2451545.0)/36525.0;

  const L0 = norm360(280.46646 + 36000.76983*T + 0.0003032*T*T);
  const M  = norm360(357.52911 + 35999.05029*T - 0.0001537*T*T);

  const Mr = deg2rad(M);
  const C = (1.914602 - 0.004817*T - 0.000014*T*T)*Math.sin(Mr)
          + (0.019993 - 0.000101*T)*Math.sin(2*Mr)
          + 0.000289*Math.sin(3*Mr);

  const trueLong = norm360(L0 + C);

  if(mode === "mean"){
    return {JD,T, L0, M, C, lon: L0, trueLong, apparentLong: null};
  }

  // Î©: longitude of ascending node of Moon's mean orbit
  const Omega = 125.04 - 1934.136*T;
  const lambdaApp = norm360(trueLong - 0.00569 - 0.00478*Math.sin(deg2rad(Omega)));

  return {JD,T, L0, M, C, lon: lambdaApp, trueLong, apparentLong: lambdaApp, Omega};
}

function getTermByLon(lon){
  const deg = norm360(lon);
  const idx = Math.floor(deg/15) % 24;
  return solarTerms[idx];
}
function getPrevNextTerms(lon){
  const deg = norm360(lon);
  let prev = solarTerms[solarTerms.length-1];
  let next = solarTerms[0];
  for (let i=0;i<solarTerms.length;i++){
    if (solarTerms[i].deg <= deg) prev = solarTerms[i];
    if (solarTerms[i].deg > deg){ next = solarTerms[i]; break; }
  }
  return {prev,next};
}

// "ì ˆê¸°ì›”" ì›”ì§€ ê³„ì‚°: ì „í†µì ìœ¼ë¡œ ì…ì¶˜(315Â°)ì„ å¯…ì›” ì‹œì‘ìœ¼ë¡œ ë³¸ë‹¤.
// ì—¬ê¸°ì„œëŠ”: 315Â°~345Â°: å¯…, 345~15: å¯? (ì—°ì† ì²˜ë¦¬ í•„ìš”)
// ë‹¨ìˆœ/í‘œì¤€ ë§¤í•‘: angle from 315Â° ê¸°ì¤€ 30Â° ë‹¨ìœ„ë¡œ month index 0=å¯…
function monthBranchFromLon(lon){
  const a = norm360(lon - 315); // 315Â°(ì…ì¶˜) ê¸°ì¤€
  const idx = Math.floor(a/30) % 12; // 0..11
  const order = ["ì¸","ë¬˜","ì§„","ì‚¬","ì˜¤","ë¯¸","ì‹ ","ìœ ","ìˆ ","í•´","ì","ì¶•"];
  return order[idx];
}

// ì‹œì§€(ì‹œì£¼): KST ê¸°ì¤€ìœ¼ë¡œ 2ì‹œê°„ ë‹¨ìœ„ (23~01=ì, 01~03=ì¶• ...)
function hourBranchFromKSTHour(h){
  // h: 0..23
  // å­: 23,0 ; ä¸‘:1,2 ; å¯…:3,4 ...
  const map = ["ì","ì¶•","ì¸","ë¬˜","ì§„","ì‚¬","ì˜¤","ë¯¸","ì‹ ","ìœ ","ìˆ ","í•´"];
  if(h===23) return "ì";
  return map[Math.floor((h+1)/2)]; // 0->0,1->1,2->1,3->2 ...
}

// ê²½ê³„ ê·¼ì ‘ë„(ë¶„ ë‹¨ìœ„) ê³„ì‚°: ì ˆê¸° ê²½ê³„ê¹Œì§€ ë‚¨ì€ ì‹œê°„ì„ ê·¼ì‚¬ì ìœ¼ë¡œ ì°¾ì•„ ì‹ ë¢°ë„ í‘œì‹œ
// ë°©ë²•: í˜„ì¬ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ Â±48ì‹œê°„ ë²”ìœ„ì—ì„œ ì´ë¶„ë²•ìœ¼ë¡œ "ëª©í‘œ í™©ê²½" í†µê³¼ ì‹œê° íƒìƒ‰
function findBoundaryTime(dateStr,timeStr, mode, targetDeg){
  // returns {utcIso, minutesDelta}
  const baseUtc = new Date(kstToUTCISOString(dateStr,timeStr) + "Z");
  const baseMs = baseUtc.getTime();

  function lonAt(ms){
    const iso = new Date(ms).toISOString().replace(".000Z","");
    return solarLongitude(iso, mode).lon;
  }

  // unwrap function for crossing: compute signed difference in [-180,180)
  function diff(ms){
    const d = norm360(lonAt(ms) - targetDeg);
    return (d > 180) ? d - 360 : d;
  }

  // search window
  let left = baseMs - 48*3600*1000;
  let right= baseMs + 48*3600*1000;

  // We want nearest root of diff(ms)=0. We'll first find a bracket with sign change.
  // sample step: 2 hours
  const step = 2*3600*1000;
  let best = {ms: null, abs: Infinity};

  let prevMs = left;
  let prevV  = diff(prevMs);
  for(let ms=left+step; ms<=right; ms+=step){
    const v = diff(ms);
    // track closest sample
    if (Math.abs(v) < best.abs){ best = {ms, abs: Math.abs(v)}; }
    // sign change bracket
    if ((prevV<=0 && v>=0) || (prevV>=0 && v<=0)){
      // binary search within [prevMs, ms]
      let a=prevMs, b=ms, fa=prevV, fb=v;
      for(let i=0;i<40;i++){
        const mid = (a+b)/2;
        const fm = diff(mid);
        if ((fa<=0 && fm>=0) || (fa>=0 && fm<=0)){ b=mid; fb=fm; }
        else { a=mid; fa=fm; }
      }
      const root = (a+b)/2;
      const minutes = (root - baseMs)/60000;
      return {utcIso: new Date(root).toISOString().replace(".000Z",""), minutesDelta: minutes};
    }
    prevMs = ms; prevV = v;
  }

  // fallback: no bracket, return closest sample (rough)
  const minutes = (best.ms - baseMs)/60000;
  return {utcIso: new Date(best.ms).toISOString().replace(".000Z",""), minutesDelta: minutes, rough:true};
}

function qualityLabel(minToBoundary){
  const a = Math.abs(minToBoundary);
  if (a <= 10) return {pill:"âš ï¸ ê²½ê³„(Â±10ë¶„): í•´ì„ ë¶„ê¸° ê¶Œì¥", note:"ì ˆê¸° ê²½ê³„ì— ë§¤ìš° ê·¼ì ‘. 1) â€˜ì´ì „ ì ˆê¸°â€™ì™€ â€˜ë‹¤ìŒ ì ˆê¸°â€™ ê¸°ì¤€ í•´ì„ì„ ë‘˜ ë‹¤ ì œì‹œí•˜ëŠ” ê²ƒì´ ì•ˆì „í•©ë‹ˆë‹¤. 2) ì¶œìƒì‹œê°ì´ ëª‡ ë¶„ë§Œ ë‹¬ë¼ë„ ì›”ì§€ê°€ ë°”ë€” ìˆ˜ ìˆìŠµë‹ˆë‹¤.", score:"LOW"};
  if (a <= 60) return {pill:"ì£¼ì˜(Â±1ì‹œê°„): ê²½ê³„ ì˜í–¥ ê°€ëŠ¥", note:"ì ˆê¸° ê²½ê³„ ê·¼ì ‘. ì›”ì§€/ì ˆê¸°ì›”ì´ ë°”ë€ŒëŠ” êµ¬ê°„ì´ë¼ í•´ì„ ë¶„ê¸°(ë‘ ì‹œë‚˜ë¦¬ì˜¤ ë¹„êµ)ê°€ ì‹ ë¢°ë„ë¥¼ ì˜¬ë¦½ë‹ˆë‹¤.", score:"MED"};
  if (a <= 180) return {pill:"ë³´í†µ(Â±3ì‹œê°„): ê²½ê³„ ì˜í–¥ ì•½í•¨", note:"ê²½ê³„ì—ì„œ ì–´ëŠ ì •ë„ ë–¨ì–´ì ¸ ìˆìŒ. ì¼ë°˜ì  í•´ì„ì€ ì•ˆì •ì ì´ë‚˜, ë¶„ ë‹¨ìœ„ ì˜¤ì°¨ê°€ í° ì…ë ¥ì´ë©´ ì¬í™•ì¸ ê¶Œì¥.", score:"OK"};
  return {pill:"ì•ˆì •: ê²½ê³„ ì˜í–¥ ê±°ì˜ ì—†ìŒ", note:"ì ˆê¸° ê²½ê³„ì—ì„œ ì¶©ë¶„íˆ ë–¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤. ì›”ì§€/ì ˆê¸°ì›” ë³€ë™ ìœ„í—˜ì´ ë‚®ìŠµë‹ˆë‹¤.", score:"HIGH"};
}

/* ========= UI ========= */
function setDefaults(){
  const now = new Date();
  const y = now.getFullYear();
  const m = pad(now.getMonth()+1);
  const d = pad(now.getDate());
  document.getElementById("date").value = `${y}-${m}-${d}`;
}
setDefaults();

function calc(){
  const dateStr = document.getElementById("date").value;
  const timeStr = document.getElementById("time").value || "00:00";
  const mode = document.getElementById("mode").value;

  if(!dateStr){ alert("ë‚ ì§œë¥¼ ì…ë ¥í•˜ì„¸ìš”."); return; }

  const utcIso = kstToUTCISOString(dateStr,timeStr);
  const astro = solarLongitude(utcIso, mode);

  const lon = astro.lon; // deg
  const {prev,next} = getPrevNextTerms(lon);
  const term = getTermByLon(lon).name;
  const monthB = monthBranchFromLon(lon);
  const {h} = parseKST(dateStr,timeStr);
  const hourB = hourBranchFromKSTHour(h);

  // boundary time: nearest of prev or next? We compute both and pick closer.
  const prevCross = findBoundaryTime(dateStr,timeStr, mode, prev.deg);
  const nextCross = findBoundaryTime(dateStr,timeStr, mode, next.deg);

  const nearer = (Math.abs(prevCross.minutesDelta) <= Math.abs(nextCross.minutesDelta)) ? {which:"ì´ì „ ì ˆê¸° ê²½ê³„", obj:prev, cross:prevCross} : {which:"ë‹¤ìŒ ì ˆê¸° ê²½ê³„", obj:next, cross:nextCross};
  const q = qualityLabel(nearer.cross.minutesDelta);

  document.getElementById("lon").textContent = `${lon.toFixed(6)}Â°`;
  document.getElementById("term").textContent = term;
  document.getElementById("boundary").textContent = `${prev.name} â†’ ${next.name}`;
  document.getElementById("monthBranch").textContent = monthB;
  document.getElementById("hourBranch").textContent = hourB;

  document.getElementById("quality").textContent = q.pill;
  document.getElementById("note").textContent =
    `${q.note} (ê°€ì¥ ê°€ê¹Œìš´ ê²½ê³„: ${nearer.which} ${nearer.obj.name} @ UTC ${nearer.cross.utcIso}, Î” ${nearer.cross.minutesDelta.toFixed(1)}ë¶„)`;

  const raw =
`[SKY CHRONOS v4 â€” NASA-style solar longitude model]
Input (KST): ${dateStr} ${timeStr}
UTC: ${utcIso}
Mode: ${mode} (${mode==="apparent" ? "apparent longitude (nutation+aberration approx)" : "mean longitude (debug)"})

Solar longitude Î»: ${lon.toFixed(9)} deg
Solar-term: ${term}
Solar-term boundary: ${prev.name} â†’ ${next.name}

Month branch (ì ˆê¸°ì›”): ${monthB}
Hour branch (ì‹œì§€): ${hourB}

Nearest boundary: ${nearer.which} ${nearer.obj.name}
Boundary UTC: ${nearer.cross.utcIso}
Delta to boundary: ${nearer.cross.minutesDelta.toFixed(3)} minutes
Quality: ${q.score}

Diagnostics:
JD: ${astro.JD.toFixed(8)}
T: ${astro.T.toFixed(10)}
L0: ${astro.L0.toFixed(8)}
M: ${astro.M.toFixed(8)}
C: ${astro.C.toFixed(8)}
True longitude: ${astro.trueLong.toFixed(8)}
${mode==="apparent" ? ("Omega: "+astro.Omega.toFixed(8)) : ""}

Notes:
- This output is a computation log. Not a fortune-telling statement.
- For boundary-close cases, compare interpretations under both adjacent solar-terms/month-branches.
`;
  document.getElementById("raw").textContent = raw;
}

function copyGPT(){
  const t = document.getElementById("raw").textContent;
  navigator.clipboard.writeText(t);
  alert("GPTìš© ì¶œë ¥ì´ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.");
}
</script>
</body>
</html>

